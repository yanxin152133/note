# 朋友圈

## 输入输出样例
### 示例一
```
输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
```
### 示例二
```
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```
注意：
1. N在[1,200]的范围内
2. 对于所有学生，有M[i][i]=1
3. 如果有M[i][j]=1,则有M[j][i]=1
## 题目描述
班上有N名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知A是B的朋友，B是C的朋友，那么我们可以认为A也是C的朋友。所谓的朋友圈，是指所有朋友的集合。
给定一个N*N的矩阵M，表示班级中学生之间的朋友关系。如果M[i][j]=1,表示已知第i个和j个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。
## 思路
1.  如果已知A是B的朋友，B是C的朋友，那么我们可以认为A也是C的朋友。相当于遍历过学生0，如果他与学生1是朋友的话，就可以不用去遍历学生1。
2. 注意是否被访问这个条件
## 代码示例
```
class Solution {
   public int findCircleNum(int[][] M) {//使用深度优先搜索，类似岛屿个数的题目
        int length = M.length;//二维数组长度，即所有人的个数
        int count = 0;//统计朋友圈个数
        boolean[] flag = new boolean[length];//访问标志
        for(int i = 0;i < length;i++){//对于每个人
            if(flag[i] == false){//如果未被访问
                DFS(i,M,flag);//深度优先搜索，访问
                count++;//朋友圈个数+1
            }
        }
        return count;
    }


    //深度优先搜索
    public void DFS(int i,int[][] M,boolean[] flag){
        flag[i] = true;


        for(int j = 0;j < M[i].length;j++){
            if(flag[j] == false && M[i][j] == 1){
                DFS(j,M,flag);
            }
        }
    }
}


```