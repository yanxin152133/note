# 岛屿的最大面积

## 输入输出样例
### 示例一
```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```
对于上面这个给定矩阵应返回6.注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’
### 示例二
```
[[0,0,0,0,0,0,0,0]]
```
对于上面这个给定的矩阵，返回0
注意：给定的矩阵grid的长度和宽度都不超过50。
## 题目描述
给定一个包含了一些0和1的非空二维数组grid，一个岛屿是由四个方向（水平或者垂直）的1（代表土地）构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。
找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为0）
## 思路
1. 首先注意一个岛屿是由四个方向（水平或者垂直）的1构成的组合。
2. 使用深度优先搜索，当搜索到一个1时，同时去搜索它的水平和垂直方向的是不是1
## 代码示例
```
class Solution {
    private int m, n;
    private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};     //用于检查一个位置的上下左右位置是否为1


    public int maxAreaOfIsland(int[][] grid) {
        // 考虑grid是否为null的情况
        if (grid == null || grid.length == 0) {
            return 0;
        }
        m = grid.length;
        n = grid[0].length;
        int maxArea = 0;     //保存岛屿的最大面积
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                maxArea = Math.max(maxArea, dfs(grid, i, j));
            }
        }
        return maxArea;
    }


    private int dfs(int[][] grid, int r, int c) {
        if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] == 0) {   //如果为0则不再考虑
            return 0;
        }
        grid[r][c] = 0;   //做标记，之后不再遍历
        int area = 1;
        for (int[] d : direction) {
            area += dfs(grid, r + d[0], c + d[1]);   //对其垂直和水平方向的坐标的值进行检查
        }
        return area;
    }
}
```