# 1. 排序
## 1.1. Comparablae 接口
1. 定义一个 学生类Student，具有年龄 age和姓名username两个属性，并通过Commparable接口提供 比较规则

```java
package sort;

/**
 * @program: java
 * @description: 数据结构-排序  学生类
 * @author: Yan
 * @create: 2021-07-29 17:35
 **/


public class Student implements Comparable<Student> {
    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "username='" + username + '\'' +
                ", age=" + age +
                '}';
    }

    // 重写
    @Override
    public int compareTo(Student o) {
        return this.getAge()-o.getAge();
    }

}

```

2. 定义测试类，在测试类Test中定义测试方法 Comparable getMax(Comparable c1, Comparable c2)完成 测试

```java
package sort.test;

import sort.Student;

/**
 * @program: java
 * @description: 测试Comparable
 * @author: Yan
 * @create: 2021-07-29 17:43
 **/


public class TestComparable {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.setUsername("张三");
        s1.setAge(18);

        Student s2 = new Student();
        s2.setUsername("李四");
        s2.setAge(20);
        Comparable max = getMax(s1,s2);
        System.out.println(max);
    }
    public static Comparable getMax(Comparable c1, Comparable c2) {
        int result = c1.compareTo(c2);
        // 如果result<0,则c1比c2大
        // 如果result>0,则c1比c2小
        // 如果result==0,则c1和c2一样大
        if (result < 0) {
            return c1;
        } else {
            return c2;
        }
    }
}

```

## 1.2. 冒泡排序（Bubble Sort）
### 1.2.1. 排序原理
1. 比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值

![冒泡排序](https://live.staticflickr.com/65535/51343368464_964d9854b7_b.jpg)

### 1.2.2. 代码实现
Bubble类

```java
package sort;

/**
 * @program: java
 * @description: 冒泡排序
 * @author: Yan
 * @create: 2021-07-29 18:31
 **/


public class Bubble {
    // 对数组a中的元素进行排序
    public static void sort(Comparable[] a) {
        for (int i = a.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (greater(a[j], a[j + 1])) {
                    exch(a, j, j + 1);
                }
            }
        }
    }

    // 比较V元素是否大于w元素
    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w) > 0;
    }


    // 数组元素交换位置
    private static void exch(Comparable[] a, int i, int j) {
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }

}


```

BubbleTest类

```java
package sort.test;

import sort.Bubble;

import java.util.Arrays;

/**
 * @program: java
 * @description: 冒泡排序测试
 * @author: Yan
 * @create: 2021-07-29 18:41
 **/


public class TestBubble {
    public static void main(String[] args) {
        Integer[] a = {4, 5, 6, 3, 2, 1};
        Bubble.sort(a);
        System.out.printf(Arrays.toString(a));
    }
}

```

### 1.2.3. 时间复杂度
冒泡排序的时间复杂度为 O(n<sup>2</sup>) 

## 1.3. 选择排序
### 1.3.1. 原理
### 1.3.2. 代码实现
### 1.3.3. 时间复杂度