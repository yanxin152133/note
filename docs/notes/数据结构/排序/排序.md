# 1. 简单排序
## 1.1. Comparablae 接口
1. 定义一个 学生类Student，具有年龄 age和姓名username两个属性，并通过Commparable接口提供 比较规则

```java
package sort;

/**
 * @program: java
 * @description: 数据结构-排序  学生类
 * @author: Yan
 * @create: 2021-07-29 17:35
 **/


public class Student implements Comparable<Student> {
    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "username='" + username + '\'' +
                ", age=" + age +
                '}';
    }

    // 重写
    @Override
    public int compareTo(Student o) {
        return this.getAge()-o.getAge();
    }

}

```

2. 定义测试类，在测试类Test中定义测试方法 Comparable getMax(Comparable c1, Comparable c2)完成 测试

```java
package sort.test;

import sort.Student;

/**
 * @program: java
 * @description: 测试Comparable
 * @author: Yan
 * @create: 2021-07-29 17:43
 **/


public class TestComparable {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.setUsername("张三");
        s1.setAge(18);

        Student s2 = new Student();
        s2.setUsername("李四");
        s2.setAge(20);
        Comparable max = getMax(s1,s2);
        System.out.println(max);
    }
    public static Comparable getMax(Comparable c1, Comparable c2) {
        int result = c1.compareTo(c2);
        // 如果result<0,则c1比c2大
        // 如果result>0,则c1比c2小
        // 如果result==0,则c1和c2一样大
        if (result < 0) {
            return c1;
        } else {
            return c2;
        }
    }
}

```

## 1.2. 冒泡排序（Bubble Sort）
### 1.2.1. 排序原理
1. 比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值

![冒泡排序](https://live.staticflickr.com/65535/51343368464_964d9854b7_b.jpg)

### 1.2.2. 代码实现
Bubble API

```java
package sort;

/**
 * @program: java
 * @description: 冒泡排序
 * @author: Yan
 * @create: 2021-07-29 18:31
 **/


public class Bubble {
    // 对数组a中的元素进行排序
    public static void sort(Comparable[] a) {
        for (int i = a.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (greater(a[j], a[j + 1])) {
                    exch(a, j, j + 1);
                }
            }
        }
    }

    // 比较V元素是否大于w元素
    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w) > 0;
    }


    // 数组元素交换位置
    private static void exch(Comparable[] a, int i, int j) {
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }

}


```

BubbleTest

```java
package sort.test;

import sort.Bubble;

import java.util.Arrays;

/**
 * @program: java
 * @description: 冒泡排序测试
 * @author: Yan
 * @create: 2021-07-29 18:41
 **/


public class TestBubble {
    public static void main(String[] args) {
        Integer[] a = {4, 5, 6, 3, 2, 1};
        Bubble.sort(a);
        System.out.printf(Arrays.toString(a));
    }
}

```

### 1.2.3. 时间复杂度
冒泡排序的时间复杂度为 O(n<sup>2</sup>) 

## 1.3. 选择排序（Selection sort）
### 1.3.1. 原理
1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引处的值为最小值，最后可以找到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值

![选择排序](https://live.staticflickr.com/65535/51365337220_df977b1265.jpg")

### 1.3.2. 代码实现
Selection API

```java
package sort;

/**
 * @program: java
 * @description: 选择排序
 * @author: Yan
 * @create: 2021-08-08 16:10
 **/


public class Selection {
    // 对数组a中的元素进行排序
    public static void sort(Comparable[] a) {
        for (int i = 0; i < a.length - 2; i++) {
            // 定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置
            int minIndex = i;
            for (int j = i + 1; j < a.length; j++) {
                // 需要比较最小索引minindex处的值和j索引处的值
                if ((greater(a[minIndex], a[j]))) {
                    minIndex = j;
                }
            }
            exch(a, i, minIndex);
        }

    }

    // 比较V元素是否大于w元素
    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w) > 0;
    }


    // 数组元素交换位置
    private static void exch(Comparable[] a, int i, int j) {
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}

```

SelectionTest 

```java
package sort.test;

import sort.Selection;

import java.util.Arrays;

/**
 * @program: java
 * @description: 测试-选择排序
 * @author: Yan
 * @create: 2021-08-08 16:22
 **/


public class SelectionTest {
    public static void main(String[] args) {
        Integer[] a = {4, 6, 8, 7, 9, 2, 10, 1};
        Selection.sort(a);
        System.out.printf(Arrays.toString(a));
    }
}

```

### 1.3.3. 时间复杂度
选择排序的时间复杂度为 O(n<sup>2</sup>)，但简单选择排序的性能上还是要略优于冒泡排序。

## 1.4. 插入排序（Insertion sort）
### 1.4.1. 原理
1. 把所有的元素分为两组，已经排序的和未排序的
2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入
3. 倒序遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他元素向后移动一位

![插入排序](https://live.staticflickr.com/65535/51365378890_48368c04a4.jpg)

### 1.4.2. 代码实现
Insertion API

```java
package sort;

/**
 * @program: java
 * @description: 插入排序
 * @author: Yan
 * @create: 2021-08-08 16:41
 **/


public class Insertion {
    // 对数组a中的元素进行排序
    public static void sort(Comparable[] a) {
        for (int i = 1; i < a.length; i++) {
            for (int j = i; j > 0; j--) {
                // 比较索引j处的值和索引j-1处的值，如果索引j-1处的值比索引j处的值大，则交换数据，如果不大，那么就找到合适的位置，推出循环
                if (greater(a[j - 1], a[j])) {
                    exch(a, j - 1, j);
                } else {
                    break;
                }
            }
        }


    }

    // 比较V元素是否大于w元素
    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w) > 0;
    }


    // 数组元素交换位置
    private static void exch(Comparable[] a, int i, int j) {
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;

    }
}

```

InsertionTest

```java
package sort.test;

import sort.Insertion;

import java.util.Arrays;

/**
 * @program: java
 * @description: 测试-插入排序
 * @author: Yan
 * @create: 2021-08-08 16:49
 **/


public class InsertionTest {
    public static void main(String[] args) {
        Integer[] a = {4, 3, 2, 10, 12, 1, 5, 6};
        Insertion.sort(a);
        System.out.printf(Arrays.toString(a));
    }
}

```

### 1.4.3. 时间复杂度
插入排序的时间复杂度为 O(n<sup>2</sup>)，直接插入排序法比冒泡和选择排序的性能要好。

# 2. 高级排序